/**
 * Workflow Generation Engine - MVP Implementation
 * 
 * This service implements intelligent n8n workflow generation from natural language:
 * 1. Natural language → intermediate specification conversion
 * 2. Workflow pattern recognition and template selection
 * 3. Node selection based on user requirements
 * 4. Configuration parameter inference from context
 * 5. Workflow optimization and best practices application
 */

import { openAIService } from './OpenAIService';
import { RequirementSpec } from './AIProcessingEngine';

export interface N8nNode {
  id: string;
  name: string;
  type: string;
  position: [number, number];
  parameters: Record<string, any>;
  credentials?: Record<string, string>;
}

export interface N8nConnection {
  node: string;
  type: 'main' | 'ai';
  index: number;
}

export interface N8nWorkflow {
  id?: string;
  name: string;
  active: boolean;
  nodes: N8nNode[];
  connections: Record<string, { main: N8nConnection[][] }>;
  settings: Record<string, any>;
  staticData: Record<string, any>;
  tags: string[];
  meta: {
    templateCredit: string;
    generatedBy: string;
    description: string;
  };
}

export interface WorkflowPattern {
  name: string;
  description: string;
  triggers: string[];
  actions: string[];
  complexity: 'simple' | 'moderate' | 'complex';
  nodes: N8nNode[];
  connections: Record<string, any>;
}

export interface GenerationResult {
  success: boolean;
  workflow?: N8nWorkflow;
  error?: string;
  warnings: string[];
  optimizations: string[];
  estimatedComplexity: 'simple' | 'moderate' | 'complex';
  requiredCredentials: string[];
}

export class WorkflowGenerationEngine {
  private readonly WORKFLOW_GENERATION_PROMPT = `Generate a complete n8n workflow based on this specification:

REQUIREMENTS: {requirements}

Create a comprehensive n8n workflow JSON that includes:

1. WORKFLOW STRUCTURE:
   - Unique workflow name based on the requirements
   - Complete nodes array with proper n8n node types
   - Connection structure showing data flow between nodes
   - Proper positioning of nodes for visual clarity
   - Required settings and configuration

2. NODE SELECTION:
   - Use appropriate n8n node types for each requirement
   - Include trigger nodes (Webhook, Cron, Manual, HTTP Request, etc.)
   - Add processing nodes (Set, IF, Switch, Code, etc.)
   - Include output nodes (HTTP Request, Email, Slack, etc.)
   - Ensure all nodes have valid parameters

3. BEST PRACTICES:
   - Add error handling where appropriate
   - Include data validation and transformation
   - Set reasonable timeouts and retry logic
   - Use descriptive node names
   - Add helpful notes/descriptions

4. CONFIGURATION:
   - Set default parameter values
   - Mark required credentials
   - Configure data mappings between nodes
   - Set workflow metadata and tags

Return a valid n8n workflow JSON structure:
{
  "name": "Descriptive Workflow Name",
  "active": false,
  "nodes": [...],
  "connections": {...},
  "settings": {...},
  "staticData": {},
  "tags": ["automation", "generated"],
  "meta": {
    "templateCredit": "Generated by Clixen AI",
    "generatedBy": "clixen-ai",
    "description": "Brief description of what this workflow does"
  }
}`;

  private readonly NODE_OPTIMIZATION_PROMPT = `Optimize this n8n workflow for better performance and reliability:

WORKFLOW: {workflow}

Apply these optimizations:
1. Node efficiency - suggest better node choices if available
2. Connection optimization - ensure efficient data flow
3. Error handling - add appropriate error nodes where missing
4. Performance - identify potential bottlenecks
5. Best practices - ensure following n8n conventions
6. Security - flag any potential security issues

Return optimized workflow JSON and list of improvements made.`;

  private readonly PATTERN_RECOGNITION_PROMPT = `Identify the workflow pattern from these requirements:

REQUIREMENTS: {requirements}

Common n8n workflow patterns:
1. **Webhook → Process → Notify** (API integrations, form submissions)
2. **Schedule → Fetch → Transform → Store** (Data synchronization)
3. **Trigger → Condition → Branch → Actions** (Conditional automation)
4. **Monitor → Alert → Escalate** (System monitoring)
5. **Collect → Aggregate → Report** (Data collection and reporting)
6. **Event → Enrich → Route → Deliver** (Event processing)

Identify the best matching pattern and return:
{
  "pattern": "pattern_name",
  "confidence": 0.85,
  "suggested_nodes": ["node1", "node2", "node3"],
  "data_flow": "description of how data flows",
  "complexity_estimate": "simple|moderate|complex"
}`;

  // Common n8n node types for different purposes
  private readonly NODE_LIBRARY = {
    triggers: {
      'webhook': 'n8n-nodes-base.webhook',
      'cron': 'n8n-nodes-base.cron',
      'manual': 'n8n-nodes-base.manualTrigger',
      'http_request': 'n8n-nodes-base.httpRequest',
      'email_trigger': 'n8n-nodes-base.emailReadImap'
    },
    processing: {
      'set': 'n8n-nodes-base.set',
      'if': 'n8n-nodes-base.if',
      'switch': 'n8n-nodes-base.switch',
      'code': 'n8n-nodes-base.code',
      'function': 'n8n-nodes-base.function',
      'merge': 'n8n-nodes-base.merge',
      'split': 'n8n-nodes-base.splitInBatches'
    },
    outputs: {
      'http_request': 'n8n-nodes-base.httpRequest',
      'email': 'n8n-nodes-base.emailSend',
      'slack': 'n8n-nodes-base.slack',
      'discord': 'n8n-nodes-base.discord',
      'webhook_response': 'n8n-nodes-base.respondToWebhook'
    },
    integrations: {
      'google_sheets': 'n8n-nodes-base.googleSheets',
      'airtable': 'n8n-nodes-base.airtable',
      'notion': 'n8n-nodes-base.notion',
      'github': 'n8n-nodes-base.github',
      'stripe': 'n8n-nodes-base.stripe',
      'trello': 'n8n-nodes-base.trello'
    }
  };

  /**
   * Generate complete n8n workflow from requirements specification
   */
  async generateWorkflow(specification: RequirementSpec): Promise<GenerationResult> {
    try {
      console.log('[WorkflowGenerationEngine] Generating workflow from specification');

      // Step 1: Recognize workflow pattern
      const pattern = await this.recognizeWorkflowPattern(specification);
      console.log('[WorkflowGenerationEngine] Identified pattern:', pattern.pattern);

      // Step 2: Generate base workflow structure
      const baseWorkflow = await this.generateBaseWorkflow(specification, pattern);
      
      if (!baseWorkflow.success || !baseWorkflow.workflow) {
        return baseWorkflow;
      }

      // Step 3: Optimize workflow
      const optimizedWorkflow = await this.optimizeWorkflow(baseWorkflow.workflow);

      // Step 4: Validate and finalize
      const validationResult = this.validateWorkflow(optimizedWorkflow);
      
      return {
        success: validationResult.isValid,
        workflow: optimizedWorkflow,
        error: validationResult.isValid ? undefined : validationResult.errors.join('; '),
        warnings: validationResult.warnings,
        optimizations: ['Pattern-based generation', 'Node optimization', 'Connection validation'],
        estimatedComplexity: pattern.complexity_estimate || 'moderate',
        requiredCredentials: this.extractRequiredCredentials(optimizedWorkflow)
      };

    } catch (error) {
      console.error('[WorkflowGenerationEngine] Error generating workflow:', error);
      
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error during workflow generation',
        warnings: [],
        optimizations: [],
        estimatedComplexity: 'complex',
        requiredCredentials: []
      };
    }
  }

  /**
   * Recognize workflow pattern from requirements
   */
  private async recognizeWorkflowPattern(specification: RequirementSpec): Promise<{
    pattern: string;
    confidence: number;
    suggested_nodes: string[];
    data_flow: string;
    complexity_estimate: 'simple' | 'moderate' | 'complex';
  }> {
    try {
      const prompt = this.PATTERN_RECOGNITION_PROMPT.replace(
        '{requirements}',
        JSON.stringify(specification)
      );

      const response = await openAIService.simpleRequest(prompt, '', {
        model: 'gpt-4',
        maxTokens: 500,
        temperature: 0.4
      });

      return JSON.parse(response);
      
    } catch (error) {
      console.error('[WorkflowGenerationEngine] Error recognizing pattern:', error);
      
      // Fallback pattern recognition based on trigger and actions
      return {
        pattern: 'webhook_process_notify',
        confidence: 0.6,
        suggested_nodes: ['webhook', 'set', 'http_request'],
        data_flow: 'Webhook receives data → Process data → Send notification',
        complexity_estimate: specification.complexity
      };
    }
  }

  /**
   * Generate base workflow structure using GPT-4
   */
  private async generateBaseWorkflow(
    specification: RequirementSpec,
    pattern: any
  ): Promise<GenerationResult> {
    try {
      const prompt = this.WORKFLOW_GENERATION_PROMPT.replace(
        '{requirements}',
        JSON.stringify({
          ...specification,
          suggested_pattern: pattern
        })
      );

      const response = await openAIService.simpleRequest(prompt, '', {
        model: 'gpt-4',
        maxTokens: 2000,
        temperature: 0.5
      });

      // Parse the generated workflow
      const workflow = JSON.parse(response);
      
      // Ensure required fields
      if (!workflow.name || !workflow.nodes || !workflow.connections) {
        throw new Error('Generated workflow is missing required fields');
      }

      // Add unique IDs to nodes if missing
      workflow.nodes = workflow.nodes.map((node: any, index: number) => ({
        ...node,
        id: node.id || crypto.randomUUID(),
        name: node.name || `Node ${index + 1}`
      }));

      // Ensure proper positioning
      workflow.nodes = this.positionNodes(workflow.nodes);

      return {
        success: true,
        workflow: workflow as N8nWorkflow,
        warnings: [],
        optimizations: [],
        estimatedComplexity: specification.complexity,
        requiredCredentials: []
      };

    } catch (error) {
      console.error('[WorkflowGenerationEngine] Error generating base workflow:', error);
      
      // Fallback: generate simple template
      return this.generateFallbackWorkflow(specification);
    }
  }

  /**
   * Optimize workflow for better performance and reliability
   */
  private async optimizeWorkflow(workflow: N8nWorkflow): Promise<N8nWorkflow> {
    try {
      const prompt = this.NODE_OPTIMIZATION_PROMPT.replace(
        '{workflow}',
        JSON.stringify(workflow)
      );

      const response = await openAIService.simpleRequest(prompt, '', {
        model: 'gpt-3.5-turbo',
        maxTokens: 1500,
        temperature: 0.3
      });

      const optimizationResult = JSON.parse(response);
      
      if (optimizationResult.optimized_workflow) {
        return {
          ...workflow,
          ...optimizationResult.optimized_workflow,
          // Preserve original metadata
          meta: workflow.meta
        };
      }

      return workflow;
      
    } catch (error) {
      console.error('[WorkflowGenerationEngine] Error optimizing workflow:', error);
      return workflow;
    }
  }

  /**
   * Validate workflow structure and configuration
   */
  private validateWorkflow(workflow: N8nWorkflow): {
    isValid: boolean;
    errors: string[];
    warnings: string[];
  } {
    const errors: string[] = [];
    const warnings: string[] = [];

    // Check required fields
    if (!workflow.name) errors.push('Workflow name is required');
    if (!workflow.nodes || !Array.isArray(workflow.nodes)) {
      errors.push('Workflow must have a nodes array');
    }
    if (!workflow.connections) errors.push('Workflow must have connections object');

    // Validate nodes
    if (workflow.nodes) {
      workflow.nodes.forEach((node, index) => {
        if (!node.id) errors.push(`Node ${index} is missing ID`);
        if (!node.name) warnings.push(`Node ${index} is missing name`);
        if (!node.type) errors.push(`Node ${index} is missing type`);
        
        // Check for trigger nodes
        const hasTrigger = workflow.nodes.some(n => 
          n.type.includes('trigger') || 
          n.type.includes('webhook') || 
          n.type.includes('cron') ||
          n.type === 'n8n-nodes-base.manualTrigger'
        );
        
        if (!hasTrigger) {
          warnings.push('Workflow should have at least one trigger node');
        }
      });
    }

    // Validate connections
    if (workflow.connections && workflow.nodes) {
      const nodeNames = workflow.nodes.map(n => n.name);
      Object.keys(workflow.connections).forEach(nodeName => {
        if (!nodeNames.includes(nodeName)) {
          errors.push(`Connection references non-existent node: ${nodeName}`);
        }
      });
    }

    return {
      isValid: errors.length === 0,
      errors,
      warnings
    };
  }

  /**
   * Extract required credentials from workflow
   */
  private extractRequiredCredentials(workflow: N8nWorkflow): string[] {
    const credentials: string[] = [];
    
    workflow.nodes.forEach(node => {
      if (node.credentials) {
        Object.values(node.credentials).forEach(credType => {
          if (typeof credType === 'string' && !credentials.includes(credType)) {
            credentials.push(credType);
          }
        });
      }
      
      // Infer credentials from node types
      if (node.type.includes('slack')) credentials.push('Slack OAuth2');
      if (node.type.includes('google')) credentials.push('Google OAuth2');
      if (node.type.includes('github')) credentials.push('GitHub OAuth2');
      if (node.type.includes('stripe')) credentials.push('Stripe API');
    });

    return [...new Set(credentials)];
  }

  /**
   * Position nodes in a logical layout
   */
  private positionNodes(nodes: N8nNode[]): N8nNode[] {
    return nodes.map((node, index) => ({
      ...node,
      position: node.position || [200 + (index % 3) * 300, 100 + Math.floor(index / 3) * 200]
    }));
  }

  /**
   * Generate fallback workflow when AI generation fails
   */
  private generateFallbackWorkflow(specification: RequirementSpec): GenerationResult {
    const workflowName = `${specification.trigger.description} → ${specification.actions[0]?.description || 'Process'}`;
    
    const fallbackWorkflow: N8nWorkflow = {
      name: workflowName,
      active: false,
      nodes: [
        {
          id: crypto.randomUUID(),
          name: 'Trigger',
          type: 'n8n-nodes-base.webhook',
          position: [200, 100],
          parameters: {
            path: 'webhook-path',
            httpMethod: 'POST'
          }
        },
        {
          id: crypto.randomUUID(),
          name: 'Process Data',
          type: 'n8n-nodes-base.set',
          position: [500, 100],
          parameters: {
            values: {
              string: [
                {
                  name: 'processed',
                  value: 'true'
                }
              ]
            }
          }
        }
      ],
      connections: {
        'Trigger': {
          main: [[{ node: 'Process Data', type: 'main' as const, index: 0 }]]
        }
      },
      settings: {
        saveManualExecutions: true,
        saveExecutionProgress: false,
        saveDataSuccessExecution: 'all',
        saveDataErrorExecution: 'all'
      },
      staticData: {},
      tags: ['automation', 'generated', 'fallback'],
      meta: {
        templateCredit: 'Generated by Clixen AI (Fallback)',
        generatedBy: 'clixen-ai-fallback',
        description: `Fallback workflow for: ${workflowName}`
      }
    };

    return {
      success: true,
      workflow: fallbackWorkflow,
      warnings: ['Used fallback workflow template due to generation issues'],
      optimizations: ['Basic structure created'],
      estimatedComplexity: 'simple',
      requiredCredentials: []
    };
  }

  /**
   * Generate workflow from template based on pattern
   */
  async generateFromTemplate(
    pattern: string,
    parameters: Record<string, any>
  ): Promise<N8nWorkflow> {
    const templates = this.getWorkflowTemplates();
    const template = templates[pattern];
    
    if (!template) {
      throw new Error(`Unknown workflow pattern: ${pattern}`);
    }

    // Customize template with parameters
    return {
      ...template,
      name: parameters.name || template.name,
      nodes: template.nodes.map(node => ({
        ...node,
        parameters: {
          ...node.parameters,
          ...parameters[node.name] || {}
        }
      }))
    };
  }

  /**
   * Get predefined workflow templates
   */
  private getWorkflowTemplates(): Record<string, N8nWorkflow> {
    return {
      webhook_to_slack: {
        name: 'Webhook to Slack Notification',
        active: false,
        nodes: [
          {
            id: crypto.randomUUID(),
            name: 'Webhook',
            type: 'n8n-nodes-base.webhook',
            position: [200, 100],
            parameters: {
              path: 'notification',
              httpMethod: 'POST'
            }
          },
          {
            id: crypto.randomUUID(),
            name: 'Slack',
            type: 'n8n-nodes-base.slack',
            position: [500, 100],
            parameters: {
              operation: 'postMessage',
              channel: '#general',
              text: '={{$json.message}}'
            },
            credentials: {
              slackOAuth2Api: 'slack_oauth2'
            }
          }
        ],
        connections: {
          'Webhook': {
            main: [[{ node: 'Slack', type: 'main' as const, index: 0 }]]
          }
        },
        settings: {},
        staticData: {},
        tags: ['webhook', 'slack', 'notification'],
        meta: {
          templateCredit: 'Clixen AI Template',
          generatedBy: 'clixen-template',
          description: 'Simple webhook to Slack notification workflow'
        }
      }
    };
  }
}

// Export singleton instance
export const workflowGenerationEngine = new WorkflowGenerationEngine();